<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ibm.20161021125730.1"><vh>@settings</vh>
<v t="ibm.20161021125730.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="ibm.20161021125730.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="ibm.20161021125710.2"><vh>有關 2016fallcadp</vh></v>
<v t="ibm.20161021125827.1"><vh>刪除 gh-page 分支</vh></v>
<v t="ibm.20161021130015.1" a="E"><vh>課程議題</vh>
<v t="ibm.20161021130112.1"><vh>期中自評連結</vh>
<v t="ibm.20161021130311.1"><vh>2a分組名單</vh></v>
<v t="ibm.20161021130236.1"><vh>2b分組名單</vh></v>
<v t="ibm.20161021130401.1"><vh>組員如何互評</vh></v>
</v>
</v>
<v t="ibm.20161021132003.1" a="E"><vh>@path ../</vh>
<v t="ibm.20161021132334.1"><vh>@button pelican-blog</vh></v>
<v t="yen.20161105104442.1"><vh>@edit README.md</vh></v>
<v t="yen.20161105104737.1"><vh>@edit .gitignore</vh></v>
<v t="ibm.20161021132211.1" a="E"><vh>Pelican 設定</vh>
<v t="ibm.20161021132307.1"><vh>@edit local_publishconf.py</vh></v>
<v t="ibm.20161021132252.1"><vh>@edit pelicanconf.py</vh></v>
</v>
<v t="ibm.20161021132021.1"><vh>@clean index.html</vh>
<v t="ibm.20161021132021.2" a="E"><vh>html</vh>
<v t="ibm.20161021132021.3"><vh>head</vh></v>
<v t="ibm.20161021132021.4" a="E"><vh>body</vh>
<v t="ibm.20161021132021.5" a="E"><vh>reveal div</vh>
<v t="ibm.20161021132021.6" a="E"><vh>slides div</vh>
<v t="ibm.20161021132021.7" a="E"><vh>封面投影片</vh>
<v t="ibm.20161021132021.8"><vh>封面投影片內容</vh></v>
</v>
<v t="ibm.20161021132021.9"><vh>快捷鍵</vh>
<v t="ibm.20161021132021.10"><vh>投影片快捷鍵</vh></v>
</v>
<v t="ibm.20161021132021.11"><vh>三大主題教學</vh>
<v t="ibm.20161021132021.12" a="E"><vh>主題教學</vh>
<v t="ibm.20161021132021.13"><vh>電腦輔助設計在教什麼?</vh></v>
</v>
<v t="ibm.20161021132021.14" a="E"><vh>主題教學內容</vh>
<v t="ibm.20161021132021.15"><vh>電腦輔助設計在教什麼?</vh></v>
</v>
<v t="ibm.20161021132021.16" a="E"><vh>相關課程</vh>
<v t="ibm.20161021132021.17"><vh>電腦輔助設計系列課程</vh></v>
</v>
<v t="ibm.20161021132021.18" a="E"><vh>創造力</vh>
<v t="ibm.20161021132021.19"><vh>何謂創造力?</vh></v>
</v>
<v t="ibm.20161021132021.20" a="E"><vh>創造力</vh>
<v t="ibm.20161021132021.21"><vh>何謂創造力?</vh></v>
</v>
<v t="ibm.20161021132021.22" a="E"><vh>所謂自學</vh>
<v t="ibm.20161021132021.23"><vh>自學的訓練</vh></v>
</v>
<v t="ibm.20161021132021.24" a="E"><vh>執行力</vh>
<v t="ibm.20161021132021.25"><vh>高效執行力</vh></v>
</v>
</v>
<v t="ibm.20161021132021.26"><vh>CADP 課程倉儲</vh>
<v t="ibm.20161021132021.27" a="E"><vh>課程時段與規劃</vh>
<v t="ibm.20161021132021.28"><vh>規劃、Wiki 與網誌</vh></v>
</v>
<v t="ibm.20161021132021.29" a="E"><vh>下載 miniconda 可攜環境</vh>
<v t="ibm.20161021132021.30"><vh>下載可攜程式環境</vh></v>
</v>
<v t="ibm.20161021132021.31" a="E"><vh>學員自評項目</vh>
<v t="ibm.20161021132021.32"><vh>下載可攜程式環境</vh></v>
</v>
</v>
<v t="ibm.20161021132021.33" a="E"><vh>電腦輔助設計課程內涵</vh>
<v t="ibm.20161021132021.34" a="E"><vh>電腦輔助設計課程內涵</vh>
<v t="ibm.20161021132021.35"><vh>CAD 教學主題</vh></v>
</v>
<v t="ibm.20161021132021.36"><vh>Github pages 網頁</vh>
<v t="ibm.20161021132021.37"><vh>各學員任務</vh></v>
</v>
<v t="ibm.20161021132021.38" a="E"><vh>所有操作都必須拍影片</vh>
<v t="ibm.20161021132021.39"><vh>操作影片</vh></v>
</v>
<v t="ibm.20161021132021.40" a="E"><vh>Solvespace 操作練習</vh>
<v t="ibm.20161021132021.41"><vh>Solvespace 實習</vh></v>
</v>
<v t="ibm.20161021132021.42" a="E"><vh>OnShape 操作練習</vh>
<v t="ibm.20161021132021.43"><vh>OnShape 實習</vh></v>
</v>
<v t="ibm.20161021132021.44" a="E"><vh>Nutcracker 操作練習</vh>
<v t="ibm.20161021132021.45"><vh>OnShape 實習</vh></v>
</v>
<v t="ibm.20161021132021.46" a="E"><vh>Delta Printer 組裝</vh>
<v t="ibm.20161021132021.47"><vh>機電資產品的設計考量</vh></v>
</v>
<v t="ibm.20161021132021.48" a="E"><vh>網際自評系統</vh>
<v t="ibm.20161021132021.49"><vh>Flask 網際程式</vh></v>
</v>
</v>
<v t="ibm.20161021132021.50" a="E"><vh>協同力訓練</vh>
<v t="ibm.20161021132021.51" a="E"><vh>Github 帳號</vh>
<v t="ibm.20161021132021.52"><vh>Github 倉儲網頁</vh></v>
</v>
<v t="ibm.20161021132021.53"><vh>倉儲子模組串連</vh>
<v t="ibm.20161021132021.54"><vh>學員作業網頁定版</vh></v>
</v>
<v t="ibm.20161021132021.55"><vh>倉儲版本拉回請求</vh>
<v t="ibm.20161021132021.56"><vh>Github 倉儲拉回請求</vh></v>
</v>
</v>
<v t="ibm.20161021132021.57"><vh>各式內容引用範例</vh>
<v t="ibm.20161021132021.58" a="E"><vh>導入數學符號與方程式</vh>
<v t="ibm.20161021132021.59"><vh>LaTeX 格式方程式</vh></v>
</v>
<v t="ibm.20161021132021.60" a="E"><vh>導入縮排程式碼</vh>
<v t="ibm.20161021132021.61"><vh>引用程式碼</vh></v>
</v>
<v t="ibm.20161021132021.62" a="E"><vh>導入影片</vh>
<v t="ibm.20161021132021.63"><vh>iframe 導入影片</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="yen.20161108231114.1" a="E"><vh>@path py</vh>
<v t="yen.20161108231122.1"><vh>@edit scrum-1.py</vh></v>
</v>
<v t="ibm.20161021132054.1" a="E"><vh>@path content</vh>
<v t="ibm.20161021132115.1"><vh>@edit 20161106.md</vh></v>
<v t="yen.20161105094706.1"><vh>@edit 20161106-1.md</vh></v>
<v t="yen.20161105095012.1"><vh>@edit 20161106-2.md</vh></v>
<v t="yen.20161105094844.1"><vh>@edit 20161106-3.md</vh></v>
<v t="yen.20161105101505.1"><vh>@edit 20161106-4.md</vh></v>
<v t="yen.20161108230750.1"><vh>@edit 20161107.md</vh></v>
<v t="ibm.20161021132133.1" a="E"><vh>@path pages</vh>
<v t="ibm.20161021132146.1"><vh>@edit pages_1.md</vh></v>
</v>
</v>
<v t="yen.20161105093748.1"><vh>產生 .key 與 .crt</vh></v>
</v>
<v t="yen.20161105093739.1"><vh>@button https server</vh></v>
<v t="yen.20161105200533.1"><vh>reference</vh>
<v t="yen.20161105113703.1"><vh>linkage synthesis</vh></v>
<v t="yen.20161105122128.1"><vh>DE in C</vh></v>
</v>
<v t="yen.20161105200556.1" a="E"><vh>選課人員名單</vh>
<v t="yen.20161105200556.2"><vh>@edit a.txt</vh></v>
<v t="yen.20161105200556.3"><vh>@edit b.txt</vh></v>
</v>
<v t="yen.20161105200607.1" a="E"><vh>分組名單</vh>
<v t="yen.20161105200607.2"><vh>@edit agroup.txt</vh></v>
<v t="yen.20161105200607.3"><vh>@edit bgroup.txt</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ibm.20161021125710.2">2016 Fall CADP 電腦輔助設計實習課程

倉儲位置: https://github.com/mdecourse/2016fallcadp

每一協同成員都應該要在 users 目錄下有一個 Leo 檔案

</t>
<t tx="ibm.20161021125730.1"></t>
<t tx="ibm.20161021125730.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="ibm.20161021125730.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="ibm.20161021125827.1">git branch -d local_branch</t>
<t tx="ibm.20161021130015.1">電腦使用
網路使用
github 使用
Vimeo 使用
Solvespace 使用
OnShape 使用
</t>
<t tx="ibm.20161021130112.1">已知各班分組名單, 必須設法建立班上網頁檢視與各組網頁檢視與各學員網頁檢視連結</t>
<t tx="ibm.20161021130236.1">第1組:40123252,40223128,40223130,40223215,40223233,
第2組:40223205,40223206,40423225,40423231,40423240,40423250,
第3組:40423201,40423202,40423203,40423211,40439221,42423223,
第4組:40423204,40423221,40423228,40423243,40423253,40423254,
第5組:40423205,40423227,40423235,40423236,40423237,40423238,
第6組:40423206,40423214,40423216,40423224,40423226,40423229,
第7組:40423207,40423210,40423219,40423220,40423241,40423246,
第8組:40423208,40423213,40423232,40423233,
第9組:40423209,40423212,40423217,40423218,40423239,40423255,
第10組:40423222,40423245,40423248,40423251,
第11組:40423234,40423242,40423244,40423247,40423249,40423252,</t>
<t tx="ibm.20161021130311.1">第1組:40223103,40223109,40423111,40443111,
第2組:40423101,40423103,40423104,40423117,40423136,40423144,
第3組:40423105,40423115,40423119,40423128,40423139,40423149,
第4組:40423106,40423107,40423108,40423121,40423125,40423140,
第5組:40423109,40423110,40423113,40423130,40423131,40423138,
第6組:40423112,40423116,40423118,40423127,40423137,40423152,
第7組:40423114, 40423120,40423122,40423124,
第8組:40423123,40423129,40423132,40423133,40423155,40423157,
第9組:40423126,40423135,40423150,40423154,
第10組:40423141,40423143,40423145,40423146,40423147,40423148,</t>
<t tx="ibm.20161021130401.1">各組員除自評外, 可以進行互評, 並各自簡要說明評分理由

目前使用位於 OpenShift 平台上的雲端主機

http://pygroup-ag100.rhcloud.com</t>
<t tx="ibm.20161021132003.1"></t>
<t tx="ibm.20161021132021.1">@language xml
@tabwidth -4
@others

</t>
<t tx="ibm.20161021132021.10"># 投影片快捷鍵

* 利用箭頭上下前後換頁
* 按 f 鍵進入全螢幕模式 (full screen)
* 按 s 鍵可以顯示投影片筆記 (show)
* 按 o 鍵可以切換單張或全域檢視 (overview)
* 按 b 或 . 鍵可以切換螢幕黑屏 (black)
* 按 Esc 可以退出全螢幕或全域檢視 (Escape)

</t>
<t tx="ibm.20161021132021.11">&lt;section&gt;
@others
&lt;/section&gt;
</t>
<t tx="ibm.20161021132021.12">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.13">## 電腦輔助設計在教什麼?

### 創造力
### 表達力
以及
### 協同力

</t>
<t tx="ibm.20161021132021.14">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.15"># CAD 在教什麼?

## &lt;span style="color:#FFFF00"&gt;創造力&lt;/span&gt;&lt;small&gt;=自學力+程式力+想像力&lt;/small&gt;
## &lt;span style="color:#FFFF00"&gt;表達力&lt;/span&gt;&lt;small&gt;=口語+文字+2D+3D+理論+實體&lt;/small&gt;
&lt;span style="color:#00FF80"&gt;以及&lt;/span&gt;
## &lt;span style="color:#FFFF00"&gt;協同力&lt;/span&gt;&lt;small&gt;=電腦+網路+工具+專案&lt;/small&gt;

</t>
<t tx="ibm.20161021132021.16">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.17"># CAD 系列課程

## 計算機程式
## 網際內容管理
&lt;span style="color:#00FF80"&gt;還有&lt;/span&gt;
## 協同產品設計實習
也在研習&lt;span style="color:#FFFF00"&gt;創造力&lt;/span&gt;、&lt;span style="color:#FFFF00"&gt;表達力&lt;/span&gt;與&lt;span style="color:#FFFF00"&gt;協同力&lt;/span&gt;

</t>
<t tx="ibm.20161021132021.18">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.19"># 何謂創造力?

## 能夠&lt;small&gt;&lt;span style="color:#FF0080"&gt;持續&lt;/span&gt;&lt;/small&gt;&lt;span style="color:#FFFF00"&gt;自學&lt;/span&gt;
## 會安排&lt;small&gt;&lt;span style="color:#FF0080"&gt;高效&lt;/span&gt;&lt;/small&gt;&lt;span style="color:#FFFF00"&gt;可執行&lt;/span&gt;流程
&lt;span style="color:#00FF80"&gt;還有&lt;/span&gt;
## 俱備&lt;small&gt;&lt;span style="color:#FF0080"&gt;豐富&lt;/span&gt;&lt;/small&gt;&lt;span style="color:#FFFF00"&gt;想像力&lt;/span&gt;

</t>
<t tx="ibm.20161021132021.2">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
@others
&lt;/html&gt;
</t>
<t tx="ibm.20161021132021.20">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.21"># 何謂創造力?

## 能夠&lt;small&gt;&lt;span style="color:#FF0080"&gt;持續&lt;/span&gt;&lt;/small&gt;自學-&gt;&lt;span style="color:#FFFF00"&gt;不一定都要別人教&lt;/span&gt;
## 會安排&lt;small&gt;&lt;span style="color:#FF0080"&gt;高效&lt;/span&gt;&lt;/small&gt;可執行流程-&gt;展現&lt;span style="color:#FFFF00"&gt;執行力&lt;/span&gt;
&lt;span style="color:#00FF80"&gt;還有&lt;/span&gt;
## 俱備&lt;small&gt;&lt;span style="color:#FF0080"&gt;豐富&lt;/span&gt;&lt;/small&gt;想像力-&gt;不受限, &lt;span style="color:#FFFF00"&gt;積極進行改造&lt;/span&gt;

</t>
<t tx="ibm.20161021132021.22">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.23"># 自學的訓練

## 學員必須自己有學習動機
## 能消化中英文資料
## 從中體會學習的意義


</t>
<t tx="ibm.20161021132021.24">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.25"># 高效執行力

## 用對的方法
## 在對的時機
## 找對的人
## 作對的事


</t>
<t tx="ibm.20161021132021.26">&lt;section&gt;
@others
&lt;/section&gt;
</t>
<t tx="ibm.20161021132021.27">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.28"># 電腦輔助設計實習課程規劃

## [課程規劃](https://github.com/mdecourse/2016fallcadp/blob/master/syllabus.py)
## [課程 Wiki](https://github.com/mdecourse/2016fallcadp/wiki)
## [課程網誌](http://chiamingyen.github.io/kmolab/blog/tag/2016fallcadp.html)

</t>
<t tx="ibm.20161021132021.29">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.3">&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
&lt;title&gt;
2016 Fall 電腦輔助設計實習課程
&lt;/title&gt;
    &lt;meta name="description" content="A framework for easily creating beautiful presentations using HTML"&gt;
    &lt;meta name="author" content="Hakim El Hattab"&gt;
    
    &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;
    &lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"&gt;
    
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;
    
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/css/reveal.css"&gt;
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/css/theme/black.css" id="theme"&gt;
    
    &lt;!-- Theme used for syntax highlighting of code --&gt;
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/lib/css/zenburn.css"&gt;

    &lt;!-- Printing and PDF exports --&gt;
    &lt;script&gt;
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://cad-lab.github.io/cadlab_data/reveal/css/print/pdf.css' : 'https://cad-lab.github.io/cadlab_data/reveal/css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    &lt;/script&gt;

    &lt;!--[if lt IE 9]&gt;
    &lt;script src="https://cad-lab.github.io/cadlab_data/reveal/lib/js/html5shiv.js"&gt;&lt;/script&gt;
    &lt;![endif]--&gt;
&lt;/head&gt;

</t>
<t tx="ibm.20161021132021.30">## 下載 miniconda 可攜環境

  * 在電腦教室下載 [mini2016fall.7z](http://140.130.17.17/public/2016fall/mini2016fall_with_leo.7z)
  * 從外部下載 [mini2016fall.7z](https://140.130.17.101/download/?filepath=/home/yen/cmsimply/wsgi/local_data/downloads/mini2016fall_with_leo.7z)
  * start.bat 啟動, stop.bat 關閉
  * 建議存在隨身硬碟中使用


</t>
<t tx="ibm.20161021132021.31">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.32">## 學員自評項目

* 上課筆記與心得寫在個人的 2016fallcadp_hw 倉儲 Wiki 中
* 利用 [ShareX](https://getsharex.com/) 錄製上課操作練習影片
* 將影片加上說明字幕後, 上傳至個人 [Vimeo](https://vimeo.com/) 與 [Youtube](https://www.youtube.com)
* 每週更新個人與分組的 Github Pages 投影片與網誌</t>
<t tx="ibm.20161021132021.33">&lt;section&gt;
@others
&lt;/section&gt;</t>
<t tx="ibm.20161021132021.34">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.35">## 電腦輔助設計實習課程

教學主題

  * 課程網頁、學員網頁、分組網頁串連
  * Solvespace 零組件繪圖與機構模擬
  * OnShape 零組件繪圖與機構模擬
  * Delta 3D printer 零組件繪圖與模擬
  * Delta 3D printer 零組件列印組立
  * 建立網際自評系統


</t>
<t tx="ibm.20161021132021.36">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.37">## Github Pages 網頁

各學員必須完成

  * 個人網頁
  * Solvespace 零組件繪圖與機構模擬
  * OnShape 零組件繪圖與機構模擬
  * Delta 3D printer 零組件繪圖與模擬
  * 利用 Delta 3D printer 列印零組件並組立
  * 建立網際自評系統
</t>
<t tx="ibm.20161021132021.38">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.39">## 操作影片錄製

  * Windows 環境下使用 ShareX
  * Ubuntu 環境下使用 Kazam
  * 影片檔岸上傳到 Vimeo
  * 影片檔案上傳到 Youtube
  * 在投影片與網誌中嵌入影片檔
</t>
<t tx="ibm.20161021132021.4">&lt;body&gt;
@others
&lt;script src="https://cad-lab.github.io/cadlab_data/reveal/lib/js/head.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cad-lab.github.io/cadlab_data/reveal/js/reveal.js"&gt;&lt;/script&gt;
&lt;script&gt;
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'slide', // none/fade/slide/convex/concave/zoom

            // More info https://github.com/hakimel/reveal.js#dependencies
            dependencies: [
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/zoom-js/zoom.js', async: true },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/notes/notes.js', async: true },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/math/math.js', async: true }
            ]
        });
&lt;/script&gt;
&lt;/body&gt;
</t>
<t tx="ibm.20161021132021.40">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.41">## Solvespace 實習

  * Solvespace 零件繪製
  * Solvespace 零件組立
  * Delta 3D Printer 機構模擬
  * 平面四連桿機構模擬與驗證
  * 平面多連桿機構模擬與驗證
  * Solvespace 程式編譯
</t>
<t tx="ibm.20161021132021.42">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.43">## OnShape 實習

  * OnShape 零件繪製
  * OnShape 零件組立
  * Delta 3D Printer 機構模擬
  * 平面四連桿機構模擬與驗證
  * 平面多連桿機構模擬與驗證
  * Featurescript 範例操作
</t>
<t tx="ibm.20161021132021.44">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.45">## OnShape 實習

  * 請根據[Nutcracker手冊](http://chiamingyen.github.io/kmolab_data/files/ProEMechanism.pdf)說明完成零件繪製
  * 請完成 Nutcracker 零件組立
  * 請完成與手冊格式類似的 pdf 導引教材 (How？)
  * 請完成零件繪製教學影片(語音或字幕說明)並上傳到 Vimeo 與 Youtube
  * 若採用 Solvespace, 可否完成上述相同零組件繪製與組立?
  * 如何精確得知機構運動過程的約束位置?
</t>
<t tx="ibm.20161021132021.46">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.47">## 機電資產品的設計考量

  * 請收集與 Delta 3D printer 有關的資料
  * 請設法利用 CAD 套件完成零組件繪製與模擬
  * 上述模擬過程對於產品的開發有何用意?
  * 請討論如何完成一台可以正常列印的 Delta Printer？

</t>
<t tx="ibm.20161021132021.48">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.49">## Flask 網際程式

  * 以 CMSimfly 為例
  * 以 PyGrouf 為例
  * 以 Jupyterhub 為例
</t>
<t tx="ibm.20161021132021.5">&lt;div class="reveal"&gt;
@others
&lt;/div&gt;

</t>
<t tx="ibm.20161021132021.50">&lt;section&gt;
@others
&lt;/section&gt;</t>
<t tx="ibm.20161021132021.51">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.52"># Github 倉儲網頁

####建立個人 Github 網頁 (帳號.github.io)
####建立個人課程作業網頁 (納入投影片與網誌架構)
####組長建立分組的評量網頁 (納入投影片與網誌架構)
</t>
<t tx="ibm.20161021132021.53">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.54"># 學員作業網頁定版

###個人作業網頁內容可以隨時改版
###分組評量網頁必須在指定時間前定版
###Github 倉儲 gh-pages分支與子模組應用
</t>
<t tx="ibm.20161021132021.55">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.56"># Github 倉儲拉回請求

####分組倉儲 Collaborators 設定
####分組倉儲版本 Pull Requests 練習
####各組員實際操作影片錄製
####操作影片加字幕以及影片檔相加
</t>
<t tx="ibm.20161021132021.57">&lt;section&gt;
@others
&lt;/section&gt;</t>
<t tx="ibm.20161021132021.58">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="ibm.20161021132021.59"># 數學符號與方程式

Inline math equations go in like so: $\omega = d\phi / dt$. Display
math should get its own line and be put in in double-dollarsigns:

$$I = \int \rho R^{2} dV$$
</t>
<t tx="ibm.20161021132021.6">&lt;!-- Any section element inside of this container is displayed as a slide --&gt;
&lt;div class="slides"&gt;
@others
&lt;/div&gt;

</t>
<t tx="ibm.20161021132021.60">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="ibm.20161021132021.61">## 利用 Markdown 寫投影片
以下利用 Markdown 格式展示 Python 程式碼:
```
@language python
# use threading and subprocess to threading the make process
import os
import subprocess
import threading

def domake():
    
    path = "../exposed/api/exposed"
    ubuntu = "../Ubuntu"
    
    # create obj path
    
    if not os.path.exists(path+"/../obj"):
        os.makedirs(path+"/../obj")
    
    subprocess.call(["make", "clean"], cwd=path)
    subprocess.call("make", cwd=path)
    subprocess.call(["cp", "{libslvs.so, _slvs.so, slvs.py}", ubuntu], cwd=path)
    subprocess.call(["python3", "circle_ex.py"], cwd=path+"/"+ubuntu)
    
make = threading.Thread(target=domake)
make.start()
```
</t>
<t tx="ibm.20161021132021.62">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.63">## 使用 iframe 導入影片

### 導入影片 template

&lt;iframe src="https://player.vimeo.com/video/183950627" width="640" height="492" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
</t>
<t tx="ibm.20161021132021.7">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132021.8">## 2016Fall 電腦輔助設計實習課程

### 虎科大機械設計工程系

&lt;small&gt;
Created by [KMOLab](http://chiamingyen.github.io/kmolab/blog/)
&lt;/small&gt;

[電腦輔助設計實習課程網誌](blog/index.html)

[甲班課程網誌](https://mdecourse.github.io/2016fallcadpa/blog)

[乙班課程網誌](https://mdecourse.github.io/2016fallcadpb/blog)

[Vimeo 上課影片](https://vimeo.com/user24079973/videos)

</t>
<t tx="ibm.20161021132021.9">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="ibm.20161021132054.1"></t>
<t tx="ibm.20161021132133.1"></t>
<t tx="ibm.20161021132211.1"></t>
<t tx="ibm.20161021132334.1">@language python
import os
#os.system("pelican content -o output -s local_publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="yen.20161105093739.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 8443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("8443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20161105093748.1">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt

</t>
<t tx="yen.20161105113703.1"># https://github.com/flukeskywalker/PyRGA
# 原始程式為 Python2 修改為 Python3 格式
# 除了原先的最大化適應值外, 增加最小化方法設定
import numpy as np
import random
from math import *
 
# 請注意各代族群數必須為 4 的倍數
class GA: # popsize must be multiple of 4
    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):
        self.EPSILON = 10e-6
        self.INFINITY = 10e6
        self.pop = []
        self.fits = []
        self.obj = obj
        self.dim = dim
        self.popsize = popsize
        self.ngen = ngen
        self.pc = pc
        self.pm = pm
        self.etac = etac
        self.etam = etam
        # min = 1 表最小化, min = -1 表最大化
        self.min = min
        self.RIGID = 0
        self.lowb = -self.INFINITY*np.ones(self.dim)
        self.highb = self.INFINITY*np.ones(self.dim)
        self.tourneylist = range(0, self.popsize)
        self.tourneysize = 2 # works for 2 for now
        self.bestmemyet = np.zeros(self.dim)
        # 若是求最大值
        if self.min == -1:
            self.bestfityet = -np.inf
        else:
        # 若是求最小值
            self.bestfityet = np.inf
        self.pop_init()
 
    def pop_init(self):
        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]
        for member in self.pop:
            for i in range(self.dim):
                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])
        self.fits = [self.obj(member) for member in self.pop]
        #self.pop_print()
        return
 
    def setbounds(self, lows, highs):
        for i in range(self.dim):
            self.lowb[i] = lows[i]
            self.highb[i] = highs[i]
        self.pop_init()
        return
 
    def run(self):
        for gen in range(self.ngen):
            print("Generation ", gen)
            self.pop = self.getnewpop()
            self.eval_pop()
            #self.pop_print()
        return [self.bestmemyet, self.bestfityet]
 
    def getnewpop(self):
        newpop = []
        #self.tourneylist = range(0, self.popsize)
        random.shuffle(list(self.tourneylist))
        self.tourneypos = 0
        for i in range(0, self.popsize, 2):
            [p1, p2] = self.getparents() #return parents, not just indices
            [c1, c2] = self.xover(p1, p2) #return children, not just indices
            c1 = self.mutate(c1)
            c2 = self.mutate(c2)
            newpop.append(c1)
            newpop.append(c2)
        return newpop
 
    def getparents(self):
        if (self.popsize - self.tourneypos) &lt; self.tourneysize:
            random.shuffle(list(self.tourneylist))
            self.tourneypos = 0
        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize
 
        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize
        return [p1, p2]
 
    def xover(self, p1, p2): # Here p1 and p2 are pop members
        c1 = np.zeros_like(p1)
        c2 = np.zeros_like(p2)
        if random.random()&lt;=self.pc: # do crossover
            for i in range(p1.size):
                if random.random()&lt;0.5: # 50% variables crossover
                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])
                else:
                    [c1[i], c2[i]] = [p1[i], p2[i]]
        else:
            c1 = p1
            c2 = p2
        return [c1, c2]
 
    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables
        if p1&gt;p2:
            p1, p2 = p2, p1 # p1 must be smaller
        mean = (p1+p2)*0.5
        diff = (p2-p1)
        dist = max(min(p1-low, high-p2), 0)
        if (self.RIGID and diff &gt; self.EPSILON):
            alpha = 1.0 + (2.0*dist/diff)
            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))
            seed = umax*random.random()
        else:
            seed = random.random()
        beta = self.getbeta(seed)
        if (abs(diff*beta) &gt; self.INFINITY):
            beta = self.INFINITY/diff
        c2 = mean + beta*0.5*diff
        c1 = mean - beta*0.5*diff
        c1 = max(low, min(c1, high))
        c2 = max(low, min(c2, high))
        return [c1, c2]
 
    def getbeta(self, seed):
        if (1 - seed) &lt; self.EPSILON:
            seed = 1 - self.EPSILON
        seed = max(0.0, seed)
        if seed &lt; 0.5:
            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))
        else:
            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))
        return beta
 
    def getdelta(self, seed, delta_low, delta_high):
        if seed &gt;= 1.0 - (self.EPSILON/1e3):
            return delta_high
        if seed &lt;= (self.EPSILON/1e3):
            return delta_low
        if seed &lt;= 0.5:
            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))
            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0
        else:
            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))
            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))
        return delta
 
    def mutate(self, member):
        mut_member = np.zeros_like(member)
        for i in range(member.size):
            low = self.lowb[i]
            high = self.highb[i]
            if random.random() &lt;= self.pm: # pm is simply the prob of a variable to mutate
                if self.RIGID:
                    value = member[i]
                    delta_low = max((low-value)/(high-low), -1.0)
                    delta_high = min((high-value)/(high-low), 1.0)
                    if abs(delta_low)&lt;abs(delta_high):
                        delta_high = -delta_low
                    else:
                        delta_low = -delta_high
                else:
                    delta_low = -1.0
                    delta_high = 1.0
                seed = random.random()
                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)
                mut_member[i] = max(low, min(member[i] + delta, high))
            else:
                mut_member[i] = member[i]
        return mut_member
 
    def eval_pop(self):
        self.fits = [self.obj(member) for member in self.pop]
        # 若是最大化適應值題目者
        if self.min == -1:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmax(self.fits)
        else:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmin(self.fits)
        bestmember = self.pop[bestindex]
        bestfitness = self.fits[bestindex]
        # self.min = -1 for maximization, self.min = 1 for minimization
        if self.min == -1:
            # 若是在族群中的最佳適應值大於目前為止最佳的適應值
            if bestfitness &gt; self.bestfityet:
                # 則將此最大適應值指為目前為止最佳適應值
                self.bestfityet = bestfitness
                # 並且將最佳族群成員指向目前最佳成員
                self.bestmemyet = bestmember
        else:
            if bestfitness &lt; self.bestfityet:
                self.bestfityet = bestfitness
                self.bestmemyet = bestmember
        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)
 
    def pop_print(self):
        for i in range(self.popsize):
            print(self.pop[i], self.fits[i])
        return
 
# 若單獨存在則需導入 GA 所有方法
#import GA
#from GA import *
import numpy as np
 
def square(x):
    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)
    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)
    term3 = term1+term2
    return term3
 
# 最大化體積題目
def volume(x):
    surface = 80.0
    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))
    volume = x[0]*x[1]*z
    return volume
 
 
def miniex1(x):
    '''Minimizing Beale's function (optimal value f(3, 0.5) = 0):
    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    term1 = 1.5 - x[0] + x[0]*x[1]
    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]
    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]
    return term1*term1 + term2*term2 + term3*term3
 
def miniex2(x):
    '''Schaffer function #2. Minimium at (0,0), equal to 0
    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    return 0.5 + (pow(sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)
 
''' 開始四連桿運算
'''
class Point(object):
    '''Creates a point on a coordinate plane with values x and y.'''
    def __init__(self, x, y):
        '''Defines x and y variables'''
        self.x = x
        self.y = y
 
def triangletip_coord(x0, y0, R0, R1, x1, y1, localt):
    mech_loop = -1
    tip_coord = Point(0,0)
    if (localt &gt;= 0 and localt &lt; pi):
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    else:
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    return tip_coord
 
def distance(x0, y0, x1, y1):
    return sqrt(pow((x1-x0),2) + pow((y1-y0),2))
 
def rr(L1, dd, theta):
    return sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta))
 
# input_angles  = [] 也就是必須為 list 且各樹為 NUM_OF_POINTS
def mechanism(x0, y0, x1, y1, L1, L2, L3, L5, L6, input_angles):
    '''
    mechanism(0,0,10,0,5,20,10,10,10,input_angles)
    x0 = 0.0;
    y0 = 0.0;
    x1 = 10.0;
    y1 = 0.0;
    L1 = 5.0;
    L2 = 10;
    L3 = 10;
    L5 = 10;
    L6 = 10;
    '''
    link1_tip = Point(0,0)
    link2_tip = Point(0,0)
    output_points = list()
    degree = pi/180.
    NUM_OF_POINTS = 5
    dd_length = distance(x0, y0, x1, y1)
    # 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式
    angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));
    for i in range(NUM_OF_POINTS):
        angle = input_angles[i]*degree
        rr_length = rr(L1, dd_length, angle)
        # 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle)
        #print(angle, rr_length, link1_tip.x, link1_tip.y)
        # 第二次三角形疊代
        # 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length))
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2)
        # 第三次三角形疊代 (改為以 finaltip_coord() 取值, 而非第三次疊代
        '''
        triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        '''
        # 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points.append(finaltip_coord(link1_tip, link2_tip, L5, L6))
    return output_points
 
def finaltip_coord(tip1_coord, tip2_coord, r1, r2):
    tip3_coord = Point(0,0)
    length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2))
    length4 = sqrt(pow(r1,2) + pow(r2,2))
    theta3 = acos((tip2_coord.x - tip1_coord.x) / length3)
    theta4 = acos(r1/length4)
    tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4)
    tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4)
    return tip3_coord
 
# 誤差函式
def error_function(output_points, target_points):
    NUM_OF_POINTS = 5
    error = 0
    for i in range(NUM_OF_POINTS):
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y))
    return error
 
# 組成機構的變數個樹 9 + 通過點數所對應的角度值, 若通過 5 點則共有 14 個變數
#   mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);
def fourbar(x):
    PENALITY = 1000
    NUM_OF_POINTS = 10
 
    # x0 與 x1 點位於 -50 與 50 中間, 0, 1, 2, 3
    for i in range(4):
        if(x[i] &lt; -50 or x[i] &gt; 50):
            return PENALITY
    # 三個連桿值, 一定要為正, 4, 5, 6,
    for i in range(4, 7):
        if(x[i] &lt; 0 or x[i] &gt;50):
            return PENALITY
   
    # L5 L6 可以為 0 或負值, 7, 8 
    for i in range(7, 9):
        if(x[i] &lt; -50 or x[i] &gt; 50):
            return PENALITY
   
    # 角度值一定要大於 0
    for i in range(NUM_OF_POINTS):
        if(x[9+i] &lt; 0):
            return PENALITY
 
    result = 0
    target_points = list()
    output_points = list()
    input_angles = list()
    # 定義四連桿關鍵點所要通過的點
    p1 = Point(1, 1)
    p2 = Point(2, 2)
    p3 = Point(3, 3)
    p4 = Point(4, 4)
    p5 = Point(5, 5)
    p6 = Point(6, 6)
    p7 = Point(7, 7)
    p8 = Point(8, 8)
    p9 = Point(9, 9)
    p10 = Point(10, 10)
    target_points = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]
    for i in range(9, 9+NUM_OF_POINTS):
        input_angles.append(x[i])
    # 這裡要加入查驗各參數是否符合四連桿組成條件
    try:
        output_points = mechanism(x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],input_angles)
    except:
        return PENALITY
    result = error_function(output_points, target_points)
    return result
 
#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化
#ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# 請注意 popsize 必須為 4 的倍數
#ga=GA(miniex1, dim=2, popsize=12, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
ga=GA(fourbar, dim=19, popsize=120000, ngen=10000, pc=0.9, pm=0.5, etac=2, etam=100, min=1)
#ga.setbounds(np.zeros(10), 10*np.ones(10))
#ga.setbounds(-10*np.ones(10), 10*np.ones(10))
ga.setbounds(-50*np.ones(20), 50*np.ones(20))
#ga.pop_init()
print(ga.run())</t>
<t tx="yen.20161105122128.1">// 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散??
 
/***************************************************************
**                                                            **
**        D I F F E R E N T I A L     E V O L U T I O N       **
**                                                            **
** Program: de.c                                              **
** Version: 3.6                                               **
**                                                            **
** Authors: Dr. Rainer Storn                                  **
**          c/o ICSI, 1947 Center Street, Suite 600           **
**          Berkeley, CA 94707                                **
**          Tel.:   510-642-4274 (extension 192)              **
**          Fax.:   510-643-7684                              **
**          E-mail: storn@icsi.berkeley.edu                   **
**          WWW: http://http.icsi.berkeley.edu/~storn/        **
**          on leave from                                     **
**          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
**          D-81739 Muenchen, Germany                         **
**          Tel:    636-40502                                 **
**          Fax:    636-44577                                 **
**          E-mail: rainer.storn@zfe.siemens.de               **
**                                                            **
**          Kenneth Price                                     **
**          836 Owl Circle                                    **
**          Vacaville, CA 95687                               **
**          E-mail: kprice@solano.community.net               ** 
**                                                            **
** This program implements some variants of Differential      **
** Evolution (DE) as described in part in the techreport      **
** tr-95-012.ps of ICSI. You can get this report either via   **
** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
** A more extended version of tr-95-012.ps is submitted for   **
** publication in the Journal Evolutionary Computation.       ** 
**                                                            **
** You may use this program for any purpose, give it to any   **
** person or change it according to your needs as long as you **
** are referring to Rainer Storn and Ken Price as the origi-  **
** nators of the the DE idea.                                 **
** If you have questions concerning DE feel free to contact   **
** us. We also will be happy to know about your experiences   **
** with DE and your suggestions of improvement.               **
**                                                            **
***************************************************************/
/**H*O*C**************************************************************
**                                                                  **
** No.!Version! Date ! Request !    Modification           ! Author **
** ---+-------+------+---------+---------------------------+------- **
**  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
**    +      +       +         + included                  +        **
**  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
**  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
**  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
**  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
**  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
**    +      +       +         + initialization            +        **
**  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
**  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
**  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
**  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
**  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
**  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
**  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
**  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
**                                                                  **
***H*O*C*E***********************************************************/
 
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "memory.h"
#include &lt;time.h&gt;
 
// 最大族群數, NP
#define MAXPOP  5000
// 最大向量維度, D
#define MAXDIM  35
#define MAXIMAPROBLEM 0
#define PENALITY 1000
 
/*------Constants for rnd_uni()--------------------------------------------*/
 
#define IM1 2147483563
#define IM2 2147483399
#define AM (1.0/IM1)
#define IMM1 (IM1-1)
#define IA1 40014
#define IA2 40692
#define IQ1 53668
#define IQ2 52774
#define IR1 12211
#define IR2 3791
#define NTAB 32
#define NDIV (1+IMM1/NTAB)
#define EPS 1.2e-7
#define RNMX (1.0-EPS)
 
// 與機構合成相關的常數定義
#define PI 3.1415926
#define degree PI/180.0
#define mech_loop -1
#define NUM_OF_POINTS 10
 
/*------------------------Macros----------------------------------------*/
 
/*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                           /* works only for small  */
                                                           /* arrays, but is faster.*/
 
/*------------------------Globals---------------------------------------*/
 
long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];
 
/*---------Function declarations----------------------------------------*/
 
void  assignd(int D, double a[], double b[]);
double rnd_uni(long *idum);    /* uniform pseudo random number generator */
double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */
 
// 與機構合成相關的函式宣告
double distance(double x0, double y0, double x1, double y1);
double rr(double L1, double dd, double theta);
struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt);
void mechanism(double x0, double y0, double x1, double y1, double L1,
  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);
   
struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);
 
/*---------Function definitions-----------------------------------------*/
// 指定向量 b 為 a
void  assignd(int D, double a[], double b[])
/**C*F****************************************************************
**                                                                  **
** Assigns D-dimensional vector b to vector a.                      **
** You might encounter problems with the macro ASSIGND on some      **
** machines. If yes, better use this function although it's slower. **
**                                                                  **
***C*F*E*************************************************************/
{
   int j;
   for (j=0; j&lt;D; j++)
   {
      a[j] = b[j];
   }
}
 
// 產生 0 ~ 1 間的亂數
double rnd_uni(long *idum)
/**C*F****************************************************************
**                                                                  **
** SRC-FUNCTION   :rnd_uni()                                        **
** LONG_NAME      :random_uniform                                   **
** AUTHOR         :(see below)                                      **
**                                                                  **
** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
**                 dom number in the interval [0,1]. For further    **
**                 reference see Press, W.H. et alii, Numerical     **
**                 Recipes in C, Cambridge University Press, 1992.  **
**                                                                  **
** FUNCTIONS      :none                                             **
**                                                                  **
** GLOBALS        :none                                             **
**                                                                  **
** PARAMETERS     :*idum    serves as a seed value                  **
**                                                                  **
** PRECONDITIONS  :*idum must be negative on the first call.        **
**                                                                  **
** POSTCONDITIONS :*idum will be changed                            **
**                                                                  **
***C*F*E*************************************************************/
{
  long j;
  long k;
  static long idum2=123456789;
  static long iy=0;
  static long iv[NTAB];
  double temp;
 
  if (*idum &lt;= 0)
  {
    if (-(*idum) &lt; 1) *idum=1;
    else *idum = -(*idum);
    idum2=(*idum);
    for (j=NTAB+7;j&gt;=0;j--)
    {
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &lt; 0) *idum += IM1;
      if (j &lt; NTAB) iv[j] = *idum;
    }
    iy=iv[0];
  }
  k=(*idum)/IQ1;
  *idum=IA1*(*idum-k*IQ1)-k*IR1;
  if (*idum &lt; 0) *idum += IM1;
  k=idum2/IQ2;
  idum2=IA2*(idum2-k*IQ2)-k*IR2;
  if (idum2 &lt; 0) idum2 += IM2;
  j=iy/NDIV;
  iy=iv[j]-idum2;
  iv[j] = *idum;
  if (iy &lt; 1) iy += IMM1;
  if ((temp=AM*iy) &gt; RNMX) return RNMX;
  else return temp;
 
}/*------End of rnd_uni()--------------------------*/
 
// 將上下限轉為全域變數
double inibound_h;      /* upper parameter bound              */
double inibound_l;      /* lower parameter bound              */
// 與機構合成相關的全域變數
// 宣告一個座標結構
struct Coord {
    double x;
    double y;
  // 這裡保留 double z;
};
 
main(int argc, char *argv[])
/**C*F****************************************************************
**                                                                  **
** SRC-FUNCTION   :main()                                           **
** LONG_NAME      :main program                                     **
** AUTHOR         :Rainer Storn, Kenneth Price                      **
**                                                                  **
** DESCRIPTION    :driver program for differential evolution.       **
**                                                                  **
** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
**                 fopen(), fclose(), fscanf().                     **
**                                                                  **
** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
**                                                                  **
** PARAMETERS     :argc            #arguments = 3                   **
**                 argv            pointer to argument strings      **
**                                                                  **
** PRECONDITIONS  :main must be called with three parameters        **
**                 e.g. like de1 &lt;input-file&gt; &lt;output-file&gt;, if     **
**                 the executable file is called de1.               **
**                 The input file must contain valid inputs accor-  **
**                 ding to the fscanf() section of main().          **
**                                                                  **
** POSTCONDITIONS :main() produces consecutive console outputs and  **
**                 writes the final results in an output file if    **
**                 the program terminates without an error.         **
**                                                                  **
***C*F*E*************************************************************/
 
{
   char  chr;             /* y/n choice variable                */
   char  *strat[] =       /* strategy-indicator                 */
   {
            "",
            "DE/best/1/exp",
            "DE/rand/1/exp",
            "DE/rand-to-best/1/exp",
            "DE/best/2/exp",
            "DE/rand/2/exp",
            "DE/best/1/bin",
            "DE/rand/1/bin",
            "DE/rand-to-best/1/bin",
            "DE/best/2/bin",
            "DE/rand/2/bin"
   };
 
   int   i, j, L, n;      /* counting variables                 */
   int   r1, r2, r3, r4;  /* placeholders for random indexes    */
   int   r5;              /* placeholders for random indexes    */
   int   D;               /* Dimension of parameter vector      */
   int   NP;              /* number of population members       */
   int   imin;            /* index to member with lowest energy */
   int   refresh;         /* refresh rate of screen output      */
   int   strategy;        /* choice parameter for screen output */
   int   gen, genmax, seed;   
 
   long  nfeval;          /* number of function evaluations     */
 
   double trial_cost;      /* buffer variable                    */
   // 將上下限轉為全域變數, 可能要根據各變數加以設定
   //double inibound_h;      /* upper parameter bound              */
   //double inibound_l;      /* lower parameter bound              */
   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
   double cost[MAXPOP];    /* obj. funct. values                 */
   double cvar;            /* computes the cost variance         */
   double cmean;           /* mean cost                          */
   double F,CR;            /* control variables of DE            */
   double cmin;            /* help variables                     */
 
   FILE  *fpin_ptr;
   FILE  *fpout_ptr;
    
// 計算執行過程所需時間起點, 需要導入 time.h
  clock_t start = clock();
   
/*------Initializations----------------------------*/
 
 //if (argc != 3)                                 /* number of arguments */
 //{
    //printf("\nUsage : de &lt;input-file&gt; &lt;output-file&gt;\n");
    //exit(1);
 //}
 
// 將結果寫入 out.dat
 fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                          /* to see whether it already exists */
 /*
 if ( fpout_ptr != NULL )
 {
    printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
    printf("want to overwrite it, \nanything else if you want to exit.\n");
    chr = (char)getchar();
    if ((chr != 'y') &amp;&amp; (chr != 'Y'))
    {
      exit(1);
    }
    fclose(fpout_ptr);
 }
*/
 
/*-----Read input data------------------------------------------------*/
 
 //fpin_ptr   = fopen(argv[1],"r");
/*
 if (fpin_ptr == NULL)
 {
    printf("\nCannot open input file\n");
    exit(1);
 }*/
  
 //fscanf(fpin_ptr,"%d",&amp;strategy);       /*---choice of strategy-----------------*/
 //fscanf(fpin_ptr,"%d",&amp;genmax);         /*---maximum number of generations------*/
 //fscanf(fpin_ptr,"%d",&amp;refresh);        /*---output refresh cycle---------------*/
 //fscanf(fpin_ptr,"%d",&amp;D);              /*---number of parameters---------------*/
 //fscanf(fpin_ptr,"%d",&amp;NP);             /*---population size.-------------------*/
 //fscanf(fpin_ptr,"%lf",&amp;inibound_h);    /*---upper parameter bound for init-----*/
 //fscanf(fpin_ptr,"%lf",&amp;inibound_l);    /*---lower parameter bound for init-----*/
 //fscanf(fpin_ptr,"%lf",&amp;F);             /*---weight factor----------------------*/
 //fscanf(fpin_ptr,"%lf",&amp;CR);            /*---crossing over factor---------------*/
 //fscanf(fpin_ptr,"%d",&amp;seed);           /*---random seed------------------------*/
// 目前已經採用 strategy 3 可以得到最佳結果
  strategy = 3;
  genmax = 2000;
  refresh = 100;
  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值
  D = 19;
  NP = 200;
  inibound_h = 50.;
  inibound_l = 0.;
/*得到最佳解
  F = 0.85;
CR 必須介於 0 to 1. 之間
  CR = 1.;
*/
  F = 0.85;
  CR = 1.;
  seed = 3;
 
 //fclose(fpin_ptr);
 
/*-----Checking input variables for proper range----------------------------*/
 
  if (D &gt; MAXDIM)
  {
     printf("\nError! D=%d &gt; MAXDIM=%d\n",D,MAXDIM);
     exit(1);
  }
  if (D &lt;= 0)
  {
     printf("\nError! D=%d, should be &gt; 0\n",D);
     exit(1);
  }
  if (NP &gt; MAXPOP)
  {
     printf("\nError! NP=%d &gt; MAXPOP=%d\n",NP,MAXPOP);
     exit(1);
  }
  if (NP &lt;= 0)
  {
     printf("\nError! NP=%d, should be &gt; 0\n",NP);
     exit(1);
  }
  if ((CR &lt; 0) || (CR &gt; 1.0))
  {
     printf("\nError! CR=%f, should be ex [0,1]\n",CR);
     exit(1);
  }
  if (seed &lt;= 0)
  {
     printf("\nError! seed=%d, should be &gt; 0\n",seed);
     exit(1);
  }
  if (refresh &lt;= 0)
  {
     printf("\nError! refresh=%d, should be &gt; 0\n",refresh);
     exit(1);
  }
  if (genmax &lt;= 0)
  {
     printf("\nError! genmax=%d, should be &gt; 0\n",genmax);
     exit(1);
  }
  if ((strategy &lt; 0) || (strategy &gt; 10))
  {
     printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
     exit(1);
  }
  if (inibound_h &lt; inibound_l)
  {
     printf("\nError! inibound_h=%f &lt; inibound_l=%f\n",inibound_h, inibound_l);
     exit(1);
  }
 
 
/*-----Open output file-----------------------------------------------*/
 
   //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */
 
   //if (fpout_ptr == NULL)
   //{
      //printf("\nCannot open output file\n");
      //exit(1);
   //}
 
 
/*-----Initialize random number generator-----------------------------*/
 
 rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
 nfeval       =  0;  /* reset number of function evaluations */
 
 
 
/*------Initialization------------------------------------------------*/
/*------Right now this part is kept fairly simple and just generates--*/
/*------random numbers in the range [-initfac, +initfac]. You might---*/
/*------want to extend the init part such that you can initialize-----*/
/*------each parameter separately.------------------------------------*/
 
   for (i=0; i&lt;NP; i++)
   {
      for (j=0; j&lt;D; j++) /* spread initial population members */
      {
        c[i][j] = inibound_l + rnd_uni(&amp;rnd_uni_init)*(inibound_h - inibound_l);
      }
      cost[i] = evaluate(D,c[i],&amp;nfeval); /* obj. funct. value */
   }
   cmin = cost[0];
   imin = 0;
   for (i=1; i&lt;NP; i++)
   {
     if(MAXIMAPROBLEM == 1)
     {
       // 改為最大化
        if (cost[i]&gt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
      else
      {
        // 最小化問題
        if (cost[i]&lt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
   }
 
   assignd(D,best,c[imin]);            /* save best member ever          */
   assignd(D,bestit,c[imin]);          /* save best member of generation */
 
   pold = &amp;c; /* old population (generation G)   */
   pnew = &amp;d; /* new population (generation G+1) */
 
/*=======================================================================*/
/*=========Iteration loop================================================*/
/*=======================================================================*/
 
   gen = 0;                          /* generation counter reset */
   while ((gen &lt; genmax) /*&amp;&amp; (kbhit() == 0)*/) /* remove comments if conio.h */
   {                                            /* is accepted by compiler    */
      gen++;
      imin = 0;
 
      for (i=0; i&lt;NP; i++)         /* Start of loop through ensemble  */
      {
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 2 !!!     */
       r1 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while(r1==i);            
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 3 !!!     */
       r2 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r2==i) || (r2==r1));
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 4 !!!     */
       r3 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r3==i) || (r3==r1) || (r3==r2));
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 5 !!!     */
       r4 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 6 !!!     */
       r5 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));
 
 
/*=======Choice of strategy===============================================================*/
/*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
/*=======DE :  stands for Differential Evolution==========================================*/
/*=======x  :  a string which denotes the vector to be perturbed==========================*/
/*=======y  :  number of difference vectors taken for perturbation of x===================*/
/*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
/*                                                                                        */
/*=======There are some simple rules which are worth following:===========================*/
/*=======1)  F is usually between 0.5 and 1 (in rare cases &gt; 1)===========================*/
/*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
/*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
/*           happens.                                                                     */
/*=======4)  If you increase NP, F usually has to be decreased============================*/
/*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/
 
 
/*=======EXPONENTIAL CROSSOVER============================================================*/
 
/*-------DE/best/1/exp--------------------------------------------------------------------*/
/*-------Our oldest strategy but still not bad. However, we have found several------------*/
/*-------optimization problems where misconvergence occurs.-------------------------------*/
     if (strategy == 1) /* strategy DE0 (not in our paper) */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/1/exp-------------------------------------------------------------------*/
/*-------This is one of my favourite strategies. It works especially well when the-------*/
/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
/*-------as a first guess.---------------------------------------------------------------*/
     else if (strategy == 2) /* strategy DE1 in the techreport */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
/*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
/*-------should play around with all three control variables.----------------------------*/
     else if (strategy == 3) /* similiar to DE2 but generally better */
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                       
         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
     else if (strategy == 4)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
     else if (strategy == 5)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
 
/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/
 
/*-------DE/best/1/bin--------------------------------------------------------------------*/
     else if (strategy == 6) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/1/bin-------------------------------------------------------------------*/
     else if (strategy == 7) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
     else if (strategy == 8) 
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/best/2/bin--------------------------------------------------------------------*/
     else if (strategy == 9)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/2/bin--------------------------------------------------------------------*/
     else
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
 
 
/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/
 
     trial_cost = evaluate(D,tmp,&amp;nfeval);  /* Evaluate new vector in tmp[] */
   if(MAXIMAPROBLEM == 1)
   {
    // 改為最大化
       if (trial_cost &gt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&gt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
    else
    {
          // 最小化問題
       if (trial_cost &lt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&lt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
     
      }   /* End mutation loop through pop. */
                        
      assignd(D,bestit,best);  /* Save best population member of current iteration */
 
      /* swap population arrays. New generation becomes old one */
 
      pswap = pold;
      pold  = pnew;
      pnew  = pswap;
 
/*----Compute the energy variance (just for monitoring purposes)-----------*/
 
      cmean = 0.;          /* compute the mean value first */
      for (j=0; j&lt;NP; j++)
      {
         cmean += cost[j];
      }
      cmean = cmean/NP;
 
      cvar = 0.;           /* now the variance              */
      for (j=0; j&lt;NP; j++)
      {
         cvar += (cost[j] - cmean)*(cost[j] - cmean);
      }
      cvar = cvar/(NP-1);
 
 
/*----Output part----------------------------------------------------------*/
 
      if (gen%refresh==1)   /* display after every refresh generations */
      { /* ABORT works only if conio.h is accepted by your compiler */
    printf("\n\n                         PRESS ANY KEY TO ABORT"); 
    printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);
 
    for (j=0;j&lt;D;j++)
    {
      printf("\n best[%d]=%-15.10g",j,best[j]);
    }
    printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
    printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
               NP,F,CR,cvar);
      }
 
      fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
   }
/*=======================================================================*/
/*=========End of iteration loop=========================================*/
/*=======================================================================*/
 
/*-------Final output in file-------------------------------------------*/
 
 
   fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);
 
   for (j=0;j&lt;D;j++)
   {
     fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
   }
   fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
   fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
           NP,F,CR,cvar); 
 
  fclose(fpout_ptr);
    
  /* Code you want timed here */
  printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
   return(0);
}
 
/*-----------End of main()------------------------------------------*/
 
// 適應函式 fittness function (cost function)
double evaluate(int D, double tmp[], long *nfeval)
{
  // 先處理通過 5 個點的四連桿問題
  // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
  // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
  // L1 為第一桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[4]
  // L2 為第二桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[5]
  // L3 為第三桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[6]
  // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
  // L5, L6 必須 &gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
  // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
  // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
  // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
  // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
  /* void mechanism(double x0, double y0, double x1, double y1, double L1,
  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
  struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
  double input_angles[NUM_OF_POINTS], result;
  int i;
   
  (*nfeval)++;
   
  target_points[0].x = 1.0;
  target_points[0].y = 1.0;
   
  target_points[1].x = 2.0;
  target_points[1].y = 2.0;
   
  target_points[2].x = 3.0;
  target_points[2].y = 3.0;
   
  target_points[3].x = 4.0;
  target_points[3].y = 4.0;
   
  target_points[4].x = 5.0;
  target_points[4].y = 5.0;
   
  target_points[5].x = 6.0;
  target_points[5].y = 6.0;
   
  target_points[6].x = 7.0;
  target_points[6].y = 7.0;
   
  target_points[7].x = 8.0;
  target_points[7].y = 8.0;
   
  target_points[8].x = 9.0;
  target_points[8].y = 9.0;
   
  target_points[9].x = 10.0;
  target_points[9].y = 10.0;
   
  // 輸入角度值與 tmp[] 的設定
  for(i = 0; i &lt; NUM_OF_POINTS; i++)
  {
    input_angles[i] = tmp[i + 9];
  }
  // 呼叫 mechanism() 以便計算 output_points[]
  mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);
   
  // for debug
  /*
  if(*nfeval%3000 == 0)
  {
    for(i = 0; i &lt; NUM_OF_POINTS; i++)
    {
      printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
    }
    printf("#####################################\n");
  }
  */
  // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
  result = error_function(output_points, target_points);
  // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result
   
  // x0 與 x1 點位於 -500 與 500 中間
    for(i = 0; i &lt; 4; i++)
  {
    if(tmp[i] &lt; -50 || tmp[i] &gt; 50){
      return PENALITY;
    }
  }
   
  // 三個連桿值, 一定要為正
    for(i = 4; i &lt; 7; i++)
  {
    if(tmp[i] &lt; 0 || tmp[i] &gt; 50){
      return PENALITY;
    }
  }
   
    // L5 L6 可以為 0 或負值
    for(i = 7; i &lt; 9; i++)
  {
    if(tmp[i] &lt; -50 || tmp[i] &gt; 50){
      return PENALITY;
    }
  }
   
  // 角度值一定要大於 0
 
  for(i = 1; i &lt;= NUM_OF_POINTS; i++)
  {
    if((tmp[D-i] &lt; 0)){
      return PENALITY;
    }
  }
   
  return result;
 
  /*
   double result=0, surface = 80.0, z, volume, penality;
   (*nfeval)++;
   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
   volume = tmp[0]*tmp[1]*z;
   
  if(volume &lt;= 0){
    return PENALITY;
  }
   
  if((tmp[0] &lt;= inibound_l)|| (tmp[0] &gt;inibound_h)){
    return PENALITY;
  }
   
  if((tmp[1] &lt;= inibound_l) || (tmp[1] &gt;inibound_h)){
    return PENALITY;
  }
  // volume must &gt;0 and max volume
  // 目前為最小化問題
   return 1+1/(volume*volume);
   */
}
 
struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
{
    struct Coord tip_coord;
 
    if (localt&gt;=0 &amp;&amp; localt &lt;PI)
    {
        // 目前蓋掉的式子為利用手動代換出來的版本
        //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
        // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
    pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
    }
    else
    {
        // 目前蓋掉的式子為利用手動代換出來的版本
        //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
    pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
    pow(x1-x0,2))/2)+x0;
    }
 
// 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
    if (localt&gt;=0 &amp;&amp; localt &lt;PI)
    {
        tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                ))
                +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                +y0;*/
                // 利用 sqrtt 居中進行代換所得到的式子
                pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
    pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
 
    }
    else
    {
        tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                ))
                +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                +y0;*/
                pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
    pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
    }
   
  return tip_coord;
}
 
double distance(double x0, double y0, double x1, double y1)
{
    double distance_value;
    distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
    return distance_value;
}
 
double rr(double L1, double dd, double theta)
{
    double rr_value;
    rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta));
    return rr_value;
}
 
// 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
void mechanism(double x0, double y0, double x1, double y1, double L1,
  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
{
  // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
  // 以下為可能的處理變數宣告
  // 這裡希望能夠定義一個 struct 來處理座標點
  double rr_length, dd_length, angle;
  struct Coord link1_tip, link2_tip, triangle_tip;
    double angle2, angle3;
  int i;
   
  // 開始進行三角形頂點座標的計算
  // 以下變數由每一個體向量提供
  /*
    x0 = 0.0;
    y0 = 0.0;
    x1 = 10.0;
    y1 = 0.0;
    L1 = 5.0;
    L2 = 20;
    L3 = 10;
    L5 = 10;
    L6 = 10;
  */
  dd_length = distance(x0, y0, x1, y1);
  /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
  angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));
   
  for(i = 0; i &lt; NUM_OF_POINTS; i++)
  {
    // 先建立第一點座標, 即 i=0 者
    // i=0;
    // angle = i*degree;
    /*
    // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
    if(i &gt; 0)
    {
      input_angles[i] = input_angles[i] + input_angles[i-1];
    }
    */
    angle = input_angles[i]*degree;
    rr_length = rr(L1, dd_length, angle);
    // 第一次三角形疊代
    link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
    // 第二次三角形疊代
    /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
    angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
    link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
    // 第三次三角形疊代
    //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
    // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
    // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
    output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
  }
}
 
double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
{
  double error = 0.0;
  int i;
  for(i = 0; i &lt; NUM_OF_POINTS; i++)
  {
    error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
  }
  return error;
}
 
struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
{
  struct Coord tip3_coord;
  double theta3, theta4, length3, length4;
  length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
  length4 = sqrt(pow(r1,2) + pow(r2,2));  
  theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
  theta4 = acos(r1 / length4);
  tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
  tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);
   
  return tip3_coord;
}</t>
<t tx="yen.20161105200533.1"></t>
<t tx="yen.20161105200556.1"></t>
<t tx="yen.20161105200607.1"></t>
<t tx="yen.20161108231114.1"></t>
</tnodes>
</leo_file>
